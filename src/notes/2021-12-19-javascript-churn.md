---
title: JavaScript churn
---

It‚Äôs come up at work that we need to evaluate [Remix](https://remix.run/) soon. It looks compelling, no doubt, but I can‚Äôt help but sigh. It was only a year ago that we moved to [Next.js](https://nextjs.org/). There is so much churn in the JavaScript world, where the one right way to do things today is the absolute wrong way to do things tomorrow. As JavaScript has come to consume the entire stack for many frontend developers, we‚Äôve had to accept change as a constant with our tools and obsolencense as an ever-present threat if we aren‚Äôt constantly upgrading dependencies. This is dramatically different from the pace at which the web platform changes, and the mirror opposite of how browsers (are supposed to) treat outdated features of frontend languages. (Consider [the community response](https://css-tricks.com/choice-words-about-the-upcoming-deprecation-of-javascript-dialogs/) to Chrome‚Äôs surprise deprecation of `alert()`.)

My reaction to hearing about Remix stemmed partly from it coming on the heels of migrating 27,000 lines of [SCSS]{.sc} to [CSS]{.sc}-in-[JS]{.sc} on a large React application. I‚Äôd been reluctant to take this on though it‚Äôd been under discussion for a couple years, but we‚Äôd liked using component styles on more recent projects and it felt necessary to keep the codebase current and more approachable to junior developers. It may turn out to be the right (or at least necessary) decision yet. But Sass was arguably the most stable part of the codebase. As we‚Äôve done more generally by adopting [CSS]{.sc}-in-[JS]{.sc}, we traded away a language we‚Äôve worked in for close to a decade, and that has hardly changed in that time, for a rotating cast of novel attempts to ‚Äùsolve‚Äù [CSS]{.sc} for JavaScript applications.

The feature sets and [API]{.sc}s of some of these libraries‚Äîwe tried out Styled Components, Emotion, and Linaria‚Äîis similar enough that one could probably move between them easily if needed. But if you‚Äôre gonna do [CSS]{.sc}-in-[JS]{.sc} you really have to commit to it; unlike with writing in Sass, which could involve as much or as little actual Sass as you wanted and could just be [CSS]{.sc}, there‚Äôs no way to casually move between vanilla [CSS]{.sc} and JavaScript strings or objects. You‚Äôre stuck with how the library tells you to write styles.

The endless churn of JavaScript-based tooling has me hankering for the stability found in working with the raw materials of the web‚Äî[HTML]{.sc}, [CSS]{.sc}, and vanilla [JS]{.sc}. No dependencies. No build tools. It‚Äôs a pipe dream, I know. (But maybe not so far from reality?) I have a nagging urge to at least rescue what parts of the stack I can from all this ‚Äúdisruption‚Äù. Beginning with [CSS]{.sc}. Maybe our team can solve the problems that we need solving with just [CSS Modules](https://github.com/css-modules/css-modules). And with [`@layer`](https://css.oddbird.net/layers/explainer/) and [scoped styles](https://css.oddbird.net/scope/explainer/) coming down the pike, maybe [CSS]{.sc} will solve these things itself soon enough. #usetheplatform‚Äîisn‚Äôt that what the Remix folks say anyway? üòâ